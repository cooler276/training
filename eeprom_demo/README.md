# 概要

* I2C通信を用いて外部EEPROMとのデータの読み書きテストを行う。

# 動作
## 初期化

1.  `i2c_init(I2C_PORT, 100 * 1000)` 関数により、指定されたI2Cポート (`I2C_PORT`) を100kHzの通信速度で初期化する。
2.  `gpio_set_function()` 関数を用いて、SDAピン (`I2C_SDA_PIN`) と SCLピン (`I2C_SCL_PIN`) をI2Cの機能として設定する。
3.  `gpio_pull_up()` 関数を用いて、SDAピンとSCLピンに内蔵プルアップ抵抗を有効にする。

## EEPROM書き込み処理

1.  `EEPROM_Write(uint8_t reg, uint8_t *pData, uint8_t Len)` 関数は、指定されたEEPROMアドレス (`reg`) から、指定されたデータ (`pData`) を指定されたバイト数 (`Len`) だけ書き込む。
2.  書き込むデータとアドレスを結合したバッファを作成し、`i2c_write_blocking()` 関数を用いてEEPROMへ送信する。この際、書き込み完了後にSTOPビットを送信する。
3.  書き込み処理後、EEPROMの書き込み動作が完了するまで `sleep_ms(5)` で待機する。

## EEPROM読み出し処理

1.  `EEPROM_Read(uint8_t reg, uint8_t *pData, uint8_t Len)` 関数は、指定されたEEPROMアドレス (`reg`) から、指定されたバイト数 (`Len`) のデータを読み出し、指定されたバッファ (`pData`) に格納する。
2.  まず、読み出すEEPROM内のアドレスを `i2c_write_blocking()` 関数で送信する。この際、STOPビットは送信しない (`true` を指定)。
3.  続いて、`i2c_read_blocking()` 関数を用いてEEPROMから指定されたバイト数のデータを読み込む。読み込み完了後にはSTOPビットを送信する (`false` を指定)。

## STOPビットについて

I2C通信では、マスターデバイス (この場合はRaspberry Pi Pico) が通信の開始と終了を制御する。<br>**STOPビット**とは通信の終了を示すもの。

- **書き込み処理におけるSTOPビット:** `EEPROM_Write()` 関数では、データの書き込みが完了した後、`i2c_write_blocking()` 関数の第4引数に `false` を指定することで、STOPビットを送信している。これにより、EEPROMはこれ以上のデータ送信がないことを認識し、内部での書き込み動作を開始する。

- **読み出し処理におけるSTOPビット:** `EEPROM_Read()` 関数では、読み出しを開始するEEPROMのアドレスを送信する際には、STOPビットを送信していない (`true` を指定)。これは、続けてデータの読み出しを行うため、通信を終了させない必要があるため。データの読み出しが完了した後、`i2c_read_blocking()` 関数の第4引数に `false` を指定することで、STOPビットを送信し、通信を終了させている。

    STOPビットを適切に送信することで、I2Cバス上の他のデバイスとの通信の衝突を防ぎ、正常な通信シーケンスを維持することが可能。

## メインループ

1.  `main()` 関数内で、まず `stdio_init_all()` 関数により標準入出力 (USBシリアルなど) を初期化する。
2.  `i2c_init_eeprom()` 関数を呼び出し、I2C通信を初期化する。
3.  書き込みテストとして、EEPROMの `0x00` アドレスに `[0xA1, 0xB2, 0xC3, 0xD4]` のデータを書き込む。
4.  書き込み処理の成否がシリアルモニタに出力される。
5.  読み出しテストとして、同じくEEPROMの `0x00` アドレスから4バイトのデータを読み出す。
6.  読み出し処理の成否と読み出したデータがシリアルモニタに出力される。
7.  書き込んだデータと読み出したデータを `memcmp()` 関数で比較し、その結果がシリアルモニタに出力される。
8.  全てのテストが終了した後、`while(true)` の無限ループに入る。

# 補足

* **I2Cポートとピン:**
    ```c
    #define I2C_PORT i2c0
    #define I2C_SDA_PIN 8
    #define I2C_SCL_PIN 9
    ```
    使用するI2Cポート (`i2c0`) と、SDA (シリアルデータ) ピンとしてGP8、SCL (シリアルクロック) ピンとしてGP9を定義している。

* **EEPROMのI2Cアドレス:**
    ```c
    #define AT24CXX_I2C_ADDR 0x50
    ```
    AT24CXXシリーズのEEPROMの一般的なI2Cアドレスとして `0x50` を定義している。使用するEEPROMの型番によっては異なる場合があるため、データシートの確認が必要。

* **I2Cの初期化:**
    `i2c_init()` 関数でI2C通信速度を設定し、`gpio_set_function()` でGPIOピンをI2C機能に割り当て、`gpio_pull_up()` でプルアップ抵抗を有効にしている。I2C通信にはプルアップ抵抗が不可欠。

* **EEPROMへの書き込み:**
    書き込む際、最初にEEPROM内のアドレスを送信する必要があるため、書き込みアドレスとデータを結合したバッファを作成している。`i2c_write_blocking()` 関数の第4引数に `false` を指定することで、書き込み完了後にSTOPビットを送信している。

* **EEPROMからの読み出し:**
    読み出す際は、まず読み出し開始アドレスを `i2c_write_blocking()` で送信し、その後に `i2c_read_blocking()` でデータを読み込んでいる。最初の書き込み時にはSTOPビットを送信しない (`true` を指定) ことで、続けて読み出し動作を行うための条件を作っている。

* **書き込み後の遅延:**
    `sleep_ms(5)` により、EEPROMの書き込み動作が完了するまで短い遅延を設けている。これは、EEPROMが書き込みコマンドに応答し、実際にデータを保存するのに時間を要するため。

* **CMakeLists.txt:** I2C関連の機能を利用するため、`target_link_libraries` に `hardware_i2c` を追加する必要がある。

    ```cmake
        target_link_libraries(eeprom_demo
            hardware_i2c
        )
    ```
